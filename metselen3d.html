<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Metselverband Simulator – 3D met Three.js</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: auto;
      padding: 15px;
    }
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    label {
      font-size: 13px;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    input, select {
      width: 90px;
      margin-left: 6px;
      padding: 2px;
    }
    button {
      margin-top: 12px;
      padding: 8px 18px;
      background: #2c7be5;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #1a68d1; }
    #result {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-weight: bold;
    }
    #scene-container {
      width: 100%;
      height: 500px;
      margin-top: 20px;
      border: 1px solid #ccc;
      background: #f0f0f0;
    }
  </style>
</head>
<body>

<h2>Metselverband Simulator – 3D Visualisatie</h2>
<p><small>Rij 0 = onderste rij • Rechte randen • Alleen 1 / ¾ / ½ stenen</small></p>

<div class="input-group">
  <label>Muurhoogte (mm) <input id="H" type="number" value="520" min="50" max="5000"></label>
  <label>Muurbreedte (mm) <input id="B" type="number" value="1000" min="100" max="5000"></label>
  <label>Steen lengte <input id="L" type="number" value="210" min="100" max="400"></label>
  <label>Steen breedte <input id="D" type="number" value="100" min="50" max="200"></label>
  <label>Steen hoogte <input id="h" type="number" value="65" min="30" max="150"></label>
  <label>Lintvoeg <input id="lv" type="number" value="10" min="0" max="30"></label>
  <label>Lintvoeg onder rij 0 <input id="lv0" type="number" value="10" min="0" max="30"></label>
  <label>Stootvoeg <input id="sv" type="number" value="10" min="0" max="30"></label>
  <label>Verband
    <select id="verband">
      <option value="halfsteen">Halfsteensverband</option>
      <option value="kruis">Kruisverband</option>
      <option value="stapel">Stapelverband</option>
      <option value="wild">Wildverband</option>
      <option value="staand">Staand verband</option>
      <option value="klezoor">Klezoorverband</option>
      <option value="ketting">Kettingverband</option>
      <option value="claustra">Claustra</option>
    </select>
  </label>
</div>

<button id="bereken">Genereer 3D-scène</button>
<div id="result"></div>
<div id="scene-container"></div>

<script>
// --- Hulpfuncties ---
function getValidSize(width, base) {
  const options = [
    { size: base, type: 'full' },
    { size: 0.75 * base, type: 'threeq' },
    { size: 0.5 * base, type: 'half' }
  ];
  let best = null;
  for (const opt of options) {
    if (opt.size <= width + 1e-6 && (!best || opt.size > best.size)) {
      best = opt;
    }
  }
  return best || { size: base, type: 'full' };
}

function buildRow(verband, rowIndex, L, D, maxB, sv) {
  const stones = [];
  let x = 0;

  // Rij 0: altijd volledige stenen, geen halve/¾
  if (rowIndex === 0) {
    while (x + L <= maxB + 1e-6) {
      stones.push({ x, width: L, isKop: false, type: 'full' });
      x += L + sv;
    }
    // Geen gedeeltelijke stenen in rij 0 → stoppen bij overschrijding
    return stones;
  }

  switch (verband) {
    case 'halfsteen':
      if (rowIndex % 2 === 0) {
        // Even rij: volledige stenen
        while (x < maxB - 1e-6) {
          const rest = maxB - x;
          const valid = getValidSize(rest, L);
          if (valid.size < 1e-6) break;
          stones.push({ x, width: valid.size, isKop: false, type: valid.type });
          x += valid.size + sv;
          if (stones.length > 100) break;
        }
      } else {
        // Oneven rij: start met halve steen
        if (L / 2 <= maxB) {
          stones.push({ x: 0, width: L / 2, isKop: false, type: 'half' });
          x = L / 2 + sv;
        }
        while (x < maxB - 1e-6) {
          const rest = maxB - x;
          const valid = getValidSize(rest, L);
          if (valid.size < 1e-6) break;
          stones.push({ x, width: valid.size, isKop: false, type: valid.type });
          x += valid.size + sv;
          if (stones.length > 100) break;
        }
      }
      break;

    case 'kruis':
      const useKop = rowIndex % 2 === 1;
      const baseDim = useKop ? D : L;
      while (x < maxB - 1e-6) {
        const rest = maxB - x;
        const valid = getValidSize(rest, baseDim);
        if (valid.size < 1e-6) break;
        stones.push({ x, width: valid.size, isKop: useKop, type: valid.type });
        x += valid.size + sv;
        if (stones.length > 100) break;
      }
      break;

    case 'stapel':
    case 'wild':
      while (x < maxB - 1e-6) {
        const rest = maxB - x;
        const valid = getValidSize(rest, L);
        if (valid.size < 1e-6) break;
        stones.push({ x, width: valid.size, isKop: false, type: valid.type });
        x += valid.size + sv;
        if (stones.length > 100) break;
      }
      break;

    case 'staand':
      while (x < maxB - 1e-6) {
        const rest = maxB - x;
        const valid = getValidSize(rest, D);
        if (valid.size < 1e-6) break;
        stones.push({ x, width: valid.size, isKop: true, type: valid.type });
        x += valid.size + sv;
        if (stones.length > 100) break;
      }
      break;

    case 'klezoor':
      let klezoorIdx = 0;
      while (x < maxB - 1e-6) {
        const isKop = klezoorIdx % 2 === 1;
        const base = isKop ? D : L;
        const rest = maxB - x;
        const valid = getValidSize(rest, base);
        if (valid.size < 1e-6) break;
        stones.push({ x, width: valid.size, isKop, type: valid.type });
        x += valid.size + sv;
        klezoorIdx++;
        if (stones.length > 100) break;
      }
      break;

    case 'ketting':
      let kettingIdx = 0;
      while (x < maxB - 1e-6) {
        const pattern = [false, false, true]; // L, L, D
        const isKop = pattern[kettingIdx % 3];
        const base = isKop ? D : L;
        const rest = maxB - x;
        const valid = getValidSize(rest, base);
        if (valid.size < 1e-6) break;
        stones.push({ x, width: valid.size, isKop, type: valid.type });
        x += valid.size + sv;
        kettingIdx++;
        if (stones.length > 100) break;
      }
      break;

    case 'claustra':
      while (x < maxB - 1e-6) {
        // Eén claustra-eenheid = steen + dubbele stootvoeg + steen
        if (x + L <= maxB + 1e-6) {
          stones.push({ x, width: L, isKop: false, type: 'full' });
          x += L + sv;
        } else {
          break;
        }
        x += L + sv; // Overslaan van tweede positie
        if (stones.length > 100) break;
      }
      break;

    default:
      while (x < maxB - 1e-6) {
        const rest = maxB - x;
        const valid = getValidSize(rest, L);
        if (valid.size < 1e-6) break;
        stones.push({ x, width: valid.size, isKop: false, type: valid.type });
        x += valid.size + sv;
        if (stones.length > 100) break;
      }
  }

  return stones;
}

// --- Berekening + 3D ---
$('#bereken').on('click', function () {
  const H = +$('#H').val();
  const B = +$('#B').val();
  const L = +$('#L').val();
  const D = +$('#D').val();
  const h = +$('#h').val();
  const lv = +$('#lv').val();
  const lv0 = +$('#lv0').val();
  const sv = +$('#sv').val();
  const verband = $('#verband').val();

  if ([H, B, L, D, h, lv, lv0, sv].some(isNaN) || H <= 0 || B <= 0 || L <= 0 || D <= 0 || h <= 0 || lv < 0 || lv0 < 0 || sv < 0) {
    $('#result').html('❌ Fout: alle waarden moeten positief getallen zijn.');
    return;
  }

  // Aantal rijen berekenen
  let rijen = 0;
  while (true) {
    const needed = lv0 + (rijen + 1) * h + rijen * lv;
    if (needed <= H + 1e-6) {
      rijen++;
    } else {
      break;
    }
    if (rijen > 200) break;
  }

  const stones3D = [];
  const count = { full: 0, threeq: 0, half: 0 };

  for (let r = 0; r < rijen; r++) {
    const y = lv0 + r * (h + lv);
    const row = buildRow(verband, r, L, D, B, sv);
    for (const stone of row) {
      const depth = stone.isKop ? L : D;
      const width = stone.width;
      const x = stone.x;
      const exceedsWidth = x + width > B + 1e-6;
      const exceedsHeight = y + h > H + 1e-6;
      const isOutside = exceedsWidth || exceedsHeight;
      if (!isOutside && ['full', 'threeq', 'half'].includes(stone.type)) {
        count[stone.type]++;
      }
      stones3D.push({ x, y, z: 0, width, depth, height: h, type: stone.type, isOutside });
    }
  }

  const total = count.full + count.threeq + count.half;
  $('#result').html(`✅ ${total} stenen in ${rijen} rijen. 3D-scène wordt geladen...`);

  renderScene({ wall: { width: B, height: H }, stones: stones3D });
});

// --- Three.js Scene ---
function renderScene(data) {
  const container = document.getElementById('scene-container');
  container.innerHTML = '';

  const { wall, stones } = data;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xeeeeee);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / 500, 1, 5000);
  camera.position.set(wall.width / 2, wall.height / 2, wall.width * 1.2);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, 500);
  renderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 2, 3);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x666666));

  const wallBox = new THREE.LineSegments(
    new THREE.EdgesGeometry(new THREE.BoxGeometry(wall.width, wall.height, 10)),
    new THREE.LineBasicMaterial({ color: 0xff0000 })
  );
  wallBox.position.set(wall.width / 2, wall.height / 2, 5);
  scene.add(wallBox);

  const matFull = new THREE.MeshLambertMaterial({ color: 0xc2b280 });
  const matThreeQ = new THREE.MeshLambertMaterial({ color: 0xaa9a60 });
  const matHalf = new THREE.MeshLambertMaterial({ color: 0xb5a570 });
  const matOutside = new THREE.MeshLambertMaterial({ color: 0xff6b6b });

  stones.forEach(stone => {
    const geom = new THREE.BoxGeometry(stone.width, stone.height, stone.depth);
    const mat = stone.isOutside ? matOutside
                : stone.type === 'full' ? matFull
                : stone.type === 'threeq' ? matThreeQ
                : matHalf;
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(stone.x + stone.width / 2, stone.y + stone.height / 2, stone.depth / 2);
    scene.add(mesh);
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / 500;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, 500);
  });
}
</script>
</body>
</html>
