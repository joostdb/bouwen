<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Metselverband Simulator – 3D met Three.js</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js';

    window.THREE = THREE;
    window.OrbitControls = OrbitControls;
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: auto;
      padding: 15px;
    }
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    label {
      font-size: 13px;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    input, select {
      width: 90px;
      margin-left: 6px;
      padding: 2px;
    }
    button {
      margin-top: 12px;
      padding: 8px 18px;
      background: #2c7be5;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #1a68d1; }
    #result {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-weight: bold;
    }
    #scene-container {
      width: 100%;
      height: 500px;
      margin-top: 20px;
      border: 1px solid #ccc;
      background: #f0f0f0;
    }
    #json-output {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      white-space: pre-wrap;
      font-family: monospace;
      max-height: 300px;
      overflow: auto;
      display: none; /* Verberg standaard */
    }
  </style>
</head>
<body>

<h2>Metselverband Simulator – 3D Visualisatie (Three.js)</h2>
<p><small>Rij 0 = onderste rij • Rechte randen • Alleen 1 / ¾ / ½ stenen</small></p>

<div class="input-group">
  <label>Muurhoogte (mm) <input id="H" type="number" value="520" min="50" max="5000"></label>
  <label>Muurbreedte (mm) <input id="B" type="number" value="1000" min="100" max="5000"></label>
  <label>Steen lengte <input id="L" type="number" value="210" min="100" max="400"></label>
  <label>Steen breedte <input id="D" type="number" value="100" min="50" max="200"></label>
  <label>Steen hoogte <input id="h" type="number" value="65" min="30" max="150"></label>
  <label>Lintvoeg <input id="lv" type="number" value="10" min="0" max="30"></label>
  <label>Lintvoeg onder rij 0 <input id="lv0" type="number" value="10" min="0" max="30"></label>
  <label>Stootvoeg <input id="sv" type="number" value="10" min="0" max="30"></label>
  <label>Verband
    <select id="verband">
      <option value="halfsteen">Halfsteensverband</option>
      <option value="kruis">Kruisverband</option>
      <option value="stapel">Stapelverband</option>
      <option value="wild">Wildverband</option>
      <option value="staand">Staand verband</option>
      <option value="klezoor">Klezoorverband</option>
      <option value="ketting">Kettingverband</option>
      <option value="claustra">Claustra</option>
    </select>
  </label>
</div>

<button id="bereken">Genereer 3D-scène</button>
<div id="result"></div>
<div id="scene-container"></div>
<pre id="json-output"></pre>

<script>
function getValidSize(width, base) {
  const options = [
    { size: base, type: 'full' },
    { size: 0.75 * base, type: 'threeq' },
    { size: 0.5 * base, type: 'half' }
  ];
  let best = null;
  for (const opt of options) {
    if (opt.size <= width + 0.1 && (!best || opt.size > best.size)) {
      best = opt;
    }
  }
  return best || { size: base, type: 'full' };
}

function buildRow(verband, rowIndex, L, D, maxB, sv) {
  const stones = [];
  let x = 0;
  let sequence = [];

  switch (verband) {
    case 'halfsteen':
      if (rowIndex % 2 === 0) sequence = [{ isKop: false, base: L }];
      else {
        stones.push({ x: 0, width: L/2, isKop: false, type: 'half' });
        x = L/2 + sv;
        sequence = [{ isKop: false, base: L }];
      }
      break;
    case 'kruis':
      if (rowIndex % 2 === 0) sequence = [{ isKop: false, base: L }];
      else sequence = [{ isKop: true, base: D }];
      break;
    case 'stapel':
    case 'wild':
      sequence = [{ isKop: false, base: L }];
      break;
    case 'staand':
      sequence = [{ isKop: true, base: D }];
      break;
    case 'klezoor':
      sequence = [{ isKop: false, base: L }, { isKop: true, base: D }];
      break;
    case 'ketting':
      sequence = [{ isKop: false, base: L }, { isKop: false, base: L }, { isKop: true, base: D }];
      break;
    case 'claustra':
      while (x < maxB + L + sv) {
        stones.push({ x, width: L, isKop: false, type: 'full' });
        x += L + sv;
        x += L + sv;
      }
      return stones;
    default:
      sequence = [{ isKop: false, base: L }];
  }

  if (verband === 'claustra') return stones;

  let idx = 0;
  while (x < maxB + L + sv) {
    const item = sequence[idx % sequence.length];
    const rest = maxB + L + sv - x;
    const valid = getValidSize(rest, item.base);
    stones.push({ x, width: valid.size, isKop: item.isKop, type: valid.type });
    x += valid.size + sv;
    idx++;
    if (idx > 50) break;
  }
  return stones;
}

$('#bereken').on('click', function () {
  const H = +$('#H').val();
  const B = +$('#B').val();
  const L = +$('#L').val();
  const D = +$('#D').val();
  const h = +$('#h').val();
  const lv = +$('#lv').val();
  const lv0 = +$('#lv0').val();
  const sv = +$('#sv').val();
  const verband = $('#verband').val();

  if ([H, B, L, D, h, lv, lv0, sv].some(isNaN) || H <= 0 || B <= 0 || L <= 0 || D <= 0 || h <= 0 || lv < 0 || lv0 < 0 || sv < 0) {
    $('#result').html('❌ Fout: alle waarden moeten positief getallen zijn.');
    return;
  }

  // Bepaal aantal rijen
  let rijen = 0;
  while (true) {
    const needed = lv0 + (rijen + 1) * h + rijen * lv;
    if (needed <= H) {
      rijen++;
    } else {
      break;
    }
    if (rijen > 200) break;
  }

  const stones3D = [];
  const count = { full: 0, threeq: 0, half: 0 };

  for (let r = 0; r < rijen; r++) {
    const y = lv0 + r * (h + lv);
    const row = buildRow(verband, r, L, D, B, sv);

    for (const stone of row) {
      const depth = stone.isKop ? L : D;
      const width = stone.width;
      const x = stone.x;

      const exceedsWidth = x + width > B;
      const exceedsHeight = y + h > H;
      const isOutside = exceedsWidth || exceedsHeight;

      if (!isOutside) count[stone.type]++;

      stones3D.push({
        x, y, z: 0,
        width,
        depth,
        height: h,
        type: stone.type,
        isOutside
      });
    }
  }

  // Opslaan voor later gebruik in Three.js
  window.masonryData = {
    wall: { width: B, height: H },
    stones: stones3D
  };

  // Toon resultaat
  const total = count.full + count.threeq + count.half;
  $('#result').html(`✅ ${total} stenen in ${rijen} rijen. 3D-scène wordt geladen...`);

  // Start Three.js-rendering (wacht tot modules geladen zijn)
  setTimeout(initThreeScene, 100);
});

// --- Three.js Scene ---
async function initThreeScene() {
  const container = document.getElementById('scene-container');
  container.innerHTML = ''; // Leeg eerst

  const { wall, stones } = window.masonryData;

  // Scene setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xeeeeee);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / 500, 1, 5000);
  camera.position.set(wall.width / 2, wall.height / 2, wall.width * 1.2);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, 500);
  renderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // Licht
  const light1 = new THREE.DirectionalLight(0xffffff, 1);
  light1.position.set(1, 2, 3);
  scene.add(light1);
  scene.add(new THREE.AmbientLight(0x666666));

  // Muurgrens (optioneel)
  const wallHelper = new THREE.LineSegments(
    new THREE.EdgesGeometry(new THREE.BoxGeometry(wall.width, wall.height, 10)),
    new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 })
  );
  wallHelper.position.set(wall.width / 2, wall.height / 2, 5);
  scene.add(wallHelper);

  // Materialen
  const matFull = new THREE.MeshLambertMaterial({ color: 0xc2b280 });
  const matThreeQ = new THREE.MeshLambertMaterial({ color: 0xaa9a60 });
  const matHalf = new THREE.MeshLambertMaterial({ color: 0xb5a570 });
  const matOutside = new THREE.MeshLambertMaterial({ color: 0xff6b6b });

  // Voeg stenen toe
  stones.forEach(stone => {
    const geom = new THREE.BoxGeometry(stone.width, stone.height, stone.depth);
    const mat = stone.isOutside
      ? matOutside
      : stone.type === 'full' ? matFull
      : stone.type === 'threeq' ? matThreeQ
      : matHalf;

    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(
      stone.x + stone.width / 2,
      stone.y + stone.height / 2,
      stone.depth / 2
    );
    scene.add(mesh);
  });

  // Animate
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Herstel bij venstergrootte
  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / 500;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, 500);
  });
}
</script>
</body>
</html>
