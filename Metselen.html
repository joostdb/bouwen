<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Metselverband Simulator ‚Äì Wienerberger Canvas</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: auto;
      padding: 20px;
    }
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    label {
      font-size: 13px;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    input, select {
      width: 90px;
      margin-left: 6px;
      padding: 2px;
    }
    button {
      margin-top: 12px;
      padding: 8px 18px;
      background: #2c7be5;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #1a68d1; }
    #result {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-weight: bold;
    }
    canvas {
      margin-top: 20px;
      border: 1px solid #666;
      background: #ffffff;
      display: block;
      width: 100%;
      max-width: 900px;
      height: auto;
    }
  </style>
</head>
<body>

<h2>Metselverband Simulator ‚Äì Wienerberger (Canvas)</h2>
<p><small>Rij 0 = onderste rij ‚Ä¢ Rechte randen ‚Ä¢ Alleen 1 / ¬æ / ¬Ω stenen + custom rest</small></p>

<div class="input-group">
  <label>Muurhoogte (mm) <input id="H" type="number" value="1080" min="50" max="5000"></label>
  <label>Muurbreedte (mm) <input id="B" type="number" value="1000" min="100" max="5000"></label>
  <label>Steen lengte <input id="L" type="number" value="210" min="100" max="400"></label>
  <label>Steen breedte <input id="D" type="number" value="100" min="50" max="200"></label>
  <label>Steen hoogte <input id="h" type="number" value="65" min="30" max="150"></label>
  <label>Lintvoeg <input id="lv" type="number" value="10" min="0" max="30"></label>
  <label>Lintvoeg onder rij 0 <input id="lv0" type="number" value="10" min="0" max="30"></label>
  <label>Stootvoeg <input id="sv" type="number" value="10" min="0" max="30"></label>
  <label>Verband
    <select id="verband">
      <option value="halfsteen">Halfsteensverband</option>
      <option value="kruis">Kruisverband</option>
      <option value="stapel">Stapelverband</option>
      <option value="wild">Wildverband</option>
      <option value="staand">Staand verband</option>
      <option value="klezoor">Klezoorverband</option>
      <option value="ketting">Kettingverband</option>
      <option value="claustra">Claustra</option>
    </select>
  </label>
</div>

<button id="bereken">Bereken & Visualiseer</button>
<div id="result"></div>
<canvas id="canvas"></canvas>

<script>
function drawStone(ctx, x, yFromBottom, w, h, color, H, scale) {
  const yCanvas = (H - (yFromBottom + h)) * scale;
  ctx.fillStyle = color;
  ctx.fillRect(x * scale, yCanvas, w * scale, h * scale);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(x * scale, yCanvas, w * scale, h * scale);
}

function getValidSize(width, base) {
  const options = [
    { size: base, type: 'full' },
    { size: 0.75 * base, type: 'threeq' },
    { size: 0.5 * base, type: 'half' }
  ];
  let best = null;
  for (const opt of options) {
    if (opt.size <= width + 0.1 && (!best || opt.size > best.size)) {
      best = opt;
    }
  }
  return best;
}

function buildRow(verband, rowIndex, L, D, maxB, sv) {
  const stones = [];
  let x = 0;
  let items = [];

  // Bepaal de sequentie van stenen voor deze rij
  switch (verband) {
    case 'halfsteen':
      if (rowIndex % 2 === 1) {
        // Oneven rij: begin met halve steen
        if (L / 2 <= maxB) {
          stones.push({ x: 0, width: L / 2, isKop: false, type: 'half' });
          x = L / 2 + sv;
        } else {
          return stones;
        }
      }
      // Beide rijen: vul met volle lengtestenen
      while (x < maxB) {
        items.push({ isKop: false, base: L });
        const rest = maxB - x;
        if (rest < 0.5 * L) break;
        const valid = getValidSize(rest, L);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: false, type: valid.type });
        x += valid.size + sv;
      }
      break;

    case 'kruis':
      const useKop = (rowIndex % 2 === 1);
      const base = useKop ? D : L;
      while (x < maxB) {
        const rest = maxB - x;
        if (rest < 0.5 * base) break;
        const valid = getValidSize(rest, base);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: useKop, type: valid.type });
        x += valid.size + sv;
      }
      break;

    case 'stapel':
    case 'wild':
      while (x < maxB) {
        const rest = maxB - x;
        if (rest < 0.5 * L) break;
        const valid = getValidSize(rest, L);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: false, type: valid.type });
        x += valid.size + sv;
      }
      break;

    case 'staand':
      while (x < maxB) {
        const rest = maxB - x;
        if (rest < 0.5 * D) break;
        const valid = getValidSize(rest, D);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: true, type: valid.type });
        x += valid.size + sv;
      }
      break;

    case 'klezoor':
      let idx = 0;
      while (x < maxB) {
        const pattern = [ { isKop: false, base: L }, { isKop: true, base: D } ];
        const item = pattern[idx % 2];
        const rest = maxB - x;
        if (rest < Math.min(0.5 * item.base, 1)) break;
        const valid = getValidSize(rest, item.base);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: item.isKop, type: valid.type });
        x += valid.size + sv;
        idx++;
      }
      break;

    case 'ketting':
      idx = 0;
      while (x < maxB) {
        const pattern = [
          { isKop: false, base: L },
          { isKop: false, base: L },
          { isKop: true, base: D }
        ];
        const item = pattern[idx % 3];
        const rest = maxB - x;
        if (rest < Math.min(0.5 * item.base, 1)) break;
        const valid = getValidSize(rest, item.base);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: item.isKop, type: valid.type });
        x += valid.size + sv;
        idx++;
      }
      break;

    case 'claustra':
      while (x < maxB) {
        if (x + L <= maxB) {
          stones.push({ x, width: L, isKop: false, type: 'full' });
        }
        x += L + sv;
        x += L + sv; // opening
      }
      return stones;

    default:
      while (x < maxB) {
        const rest = maxB - x;
        if (rest < 0.5 * L) break;
        const valid = getValidSize(rest, L);
        if (!valid) break;
        stones.push({ x, width: valid.size, isKop: false, type: valid.type });
        x += valid.size + sv;
      }
  }

  // >>> NU: ZORG VOOR RECHTE RAND <<<
  const currentEnd = stones.length > 0 ? (stones[stones.length - 1].x + stones[stones.length - 1].width) : 0;
  const gap = maxB - currentEnd;

  if (Math.abs(gap) < 0.1) {
    // Perfect
    return stones;
  }

  if (gap > 0.1) {
    // Er is ruimte over
    if (stones.length === 0) {
      // Geen stenen ‚Üí plaats √©√©n aangepaste volle steen (lengte of kop afhankelijk van verband)
      const base = (verband === 'staand' || (verband === 'kruis' && rowIndex % 2 === 1)) ? D : L;
      const width = Math.min(gap, base);
      const isKop = (base === D);
      if (width >= 0.25 * base) {
        stones.push({ x: 0, width, isKop, type: 'custom' });
      }
    } else {
      const last = stones[stones.length - 1];
      const base = last.isKop ? D : L;
      const minAllowed = 0.25 * base;

      if (gap >= minAllowed) {
        // Vervang laatste steen door een die tot B reikt
        const newWidth = last.width + gap;
        if (newWidth <= base) {
          stones[stones.length - 1] = { ...last, width: newWidth, type: 'custom' };
        } else {
          // Niet toegestaan om groter te zijn ‚Üí hou origineel (zeldzaam)
        }
      } else {
        // Gap te klein: verwijder laatste steen en vul tot B met √©√©n aangepaste volle steen
        stones.pop();
        const newStart = last.x;
        const newWidth = maxB - newStart;
        const newBase = last.isKop ? D : L;
        if (newWidth >= 0.25 * newBase && newWidth <= newBase) {
          stones.push({ x: newStart, width: newWidth, isKop: last.isKop, type: 'custom' });
        } else {
          // Fallback: plaats origineel terug
          stones.push(last);
        }
      }
    }
  } else if (gap < -0.1) {
    // Rij loopt over ‚Üí dit mag niet gebeuren, maar corrigeer veilig
    if (stones.length > 0) {
      const last = stones[stones.length - 1];
      const newWidth = last.width + gap; // gap is negatief
      const base = last.isKop ? D : L;
      if (newWidth >= 0.25 * base) {
        stones[stones.length - 1] = { ...last, width: newWidth, type: 'custom' };
      } else {
        stones.pop(); // verwijder
      }
    }
  }

  return stones;
}

$('#bereken').on('click', function () {
  const H = +$('#H').val();
  const B = +$('#B').val();
  const L = +$('#L').val();
  const D = +$('#D').val();
  const h = +$('#h').val();
  const lv = +$('#lv').val();
  const lv0 = +$('#lv0').val();
  const sv = +$('#sv').val();
  const verband = $('#verband').val();

  if ([H, B, L, D, h, lv, lv0, sv].some(isNaN) || H <= 0 || B <= 0 || L <= 0 || D <= 0 || h <= 0 || lv < 0 || lv0 < 0 || sv < 0) {
    $('#result').html('‚ùå Fout: alle waarden moeten positief getallen zijn.');
    return;
  }

  let rijen = 0;
  while (true) {
    const needed = lv0 + (rijen + 1) * h + rijen * lv;
    if (needed <= H) {
      rijen++;
    } else {
      break;
    }
    if (rijen > 200) break;
  }

  // >>> STAP 1: bouw rij 0 en bepaal sharedCustomSize <<<
  let sharedCustomSize = null;
  const row0 = buildRow(verband, 0, L, D, B, sv, null);
  // Zoek laatste steen van rij 0
  if (row0.length > 0) {
    const last0 = row0[row0.length - 1];
    if (last0.type === 'custom' && !last0.isKop) {
      sharedCustomSize = last0.width;
    }
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const viewWidth = B + 50;
  const scale = Math.min(canvas.clientWidth / viewWidth, 800 / viewWidth);
  canvas.width = viewWidth * scale;
  canvas.height = H * scale;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#ff0000';
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 1;
  ctx.strokeRect(0, 0, B * scale, H * scale);
  ctx.setLineDash([]);

  const count = { full: 0, threeq: 0, half: 0, custom: 0 };
  const customSizes = {};
  const colorMap = { 
    full: '#c2b280', 
    threeq: '#aa9a60', 
    half: '#b5a570',
    custom: '#d9534f'
  };

  // >>> STAP 2: bouw alle rijen, met sharedCustomSize <<<
  for (let r = 0; r < rijen; r++) {
    const yFromBottom = lv0 + r * (h + lv);
    if (yFromBottom + h > H) continue;

    const useShared = (r > 0) ? sharedCustomSize : null;
    const row = buildRow(verband, r, L, D, B, sv, useShared);

    for (const stone of row) {
      if (stone.x >= 0 && stone.x + stone.width <= B + 0.1) {
        if (stone.type === 'custom') {
          count.custom++;
          const wRounded = Math.round(stone.width * 10) / 10;
          customSizes[wRounded] = (customSizes[wRounded] || 0) + 1;
          drawStone(ctx, stone.x, yFromBottom, stone.width, h, colorMap.custom, H, scale);
        } else {
          count[stone.type]++;
          drawStone(ctx, stone.x, yFromBottom, stone.width, h, colorMap[stone.type], H, scale);
        }
      }
    }
  }

  // >>> Suggesties en resultaat (onveranderd) <<<
  let suggestions = '';
  const base0 = (verband === 'staand' || (verband === 'kruis' && 0 % 2 === 1)) ? D : L;
  let bestSv = null;
  for (let n = 1; n <= Math.ceil(B / base0) + 3; n++) {
    if (n === 1) {
      if (Math.abs(base0 - B) <= 1) { bestSv = sv; break; }
    } else {
      const candidate = (B - n * base0) / (n - 1);
      if (candidate >= 0 && candidate <= 30) { bestSv = candidate; break; }
    }
  }
  if (bestSv !== null && Math.abs(bestSv - sv) > 0.5) {
    suggestions += `üí° Voor exacte breedte met volle stenen in rij 0: stootvoeg = ${bestSv.toFixed(1)} mm<br>`;
  }

  if (rijen > 0) {
    const usedHeight = lv0 + rijen * h + (rijen - 1) * lv;
    const diff = H - usedHeight;
    if (Math.abs(diff) > 0.5) {
      const newLv0 = lv0 + diff;
      if (newLv0 >= 0 && newLv0 <= h / 2) {
        suggestions += `üí° Voor exacte hoogte: pas lintvoeg onder rij 0 aan naar ${newLv0.toFixed(1)} mm (‚â§¬Ω steen)<br>`;
      }
    }
  }

  const total = count.full + count.threeq + count.half + count.custom;
  let resultText = `Ingevoerde waarden:<br>`;
  resultText += `&nbsp;&nbsp;H=${H} mm, B=${B} mm<br>`;
  resultText += `&nbsp;&nbsp;lv=${lv} mm, lv0=${lv0} mm, sv=${sv} mm<br><br>`;
  resultText += `Aantal rijen (van onder): ${rijen}<br>`;
  resultText += `Volle stenen (binnen muur): ${count.full}<br>`;
  resultText += `¬æ-stenen: ${count.threeq}<br>`;
  resultText += `Halve stenen: ${count.half}<br>`;
  
  if (count.custom > 0) {
    resultText += `Aangepaste stenen (op maat): ${count.custom}<br>`;
    const sizeList = Object.keys(customSizes).sort((a,b) => parseFloat(a) - parseFloat(b));
    for (const w of sizeList) {
      resultText += `&nbsp;&nbsp;‚Ä¢ ${w} mm: ${customSizes[w]}√ó<br>`;
    }
  }
  
  resultText += `Totaal binnen muur: ${total}<br><br>`;

  if (suggestions) resultText += suggestions;
  resultText += `‚úÖ Alleen stenen binnen de muur (gestippeld kader) worden getoond en geteld.<br>`;
  resultText += `üìè Gestippelde rechthoek = opgegeven muur (B√óH).<br>`;
  if (count.custom > 0) {
    resultText += `‚ö†Ô∏è Rode stenen = afgezaagd op maat (geen standaardformaat).`;
  }

  $('#result').html(resultText);
});
</script>
</body>
</html>
