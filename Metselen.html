<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Metselverband Simulator ‚Äì Wienerberger Canvas</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: auto;
      padding: 20px;
    }
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    label {
      font-size: 13px;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    input, select {
      width: 90px;
      margin-left: 6px;
      padding: 2px;
    }
    button {
      margin-top: 12px;
      padding: 8px 18px;
      background: #2c7be5;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #1a68d1; }
    #result {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-weight: bold;
    }
    canvas {
      margin-top: 20px;
      border: 1px solid #666;
      background: #ffffff;
      display: block;
      width: 100%;
      max-width: 900px;
      height: auto;
    }
  </style>
</head>
<body>

<h2>Metselverband Simulator ‚Äì Wienerberger (Canvas)</h2>
<p><small>Rij 0 = onderste rij ‚Ä¢ Rechte randen ‚Ä¢ Alleen 1 / ¬æ / ¬Ω stenen + custom rest</small></p>

<div class="input-group">
  <label>Muurhoogte (mm) <input id="H" type="number" value="1080" min="50" max="5000"></label>
  <label>Muurbreedte (mm) <input id="B" type="number" value="1000" min="100" max="5000"></label>
  <label>Steen lengte <input id="L" type="number" value="210" min="100" max="400"></label>
  <label>Steen breedte <input id="D" type="number" value="100" min="50" max="200"></label>
  <label>Steen hoogte <input id="h" type="number" value="65" min="30" max="150"></label>
  <label>Lintvoeg <input id="lv" type="number" value="10" min="0" max="30"></label>
  <label>Lintvoeg onder rij 0 <input id="lv0" type="number" value="10" min="0" max="30"></label>
  <label>Stootvoeg <input id="sv" type="number" value="10" min="0" max="30"></label>
  <label>Verband
    <select id="verband">
      <option value="halfsteen">Halfsteensverband</option>
      <option value="kruis">Kruisverband</option>
      <option value="stapel">Stapelverband</option>
      <option value="wild">Wildverband</option>
      <option value="staand">Staand verband</option>
      <option value="klezoor">Klezoorverband</option>
      <option value="ketting">Kettingverband</option>
      <option value="claustra">Claustra</option>
    </select>
  </label>
</div>

<button id="bereken">Bereken & Visualiseer</button>
<div id="result"></div>
<canvas id="canvas"></canvas>

<script>
function drawStone(ctx, x, yFromBottom, w, h, color, H, scale) {
  const yCanvas = (H - (yFromBottom + h)) * scale;
  ctx.fillStyle = color;
  ctx.fillRect(x * scale, yCanvas, w * scale, h * scale);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(x * scale, yCanvas, w * scale, h * scale);
}

function getValidSize(width, base) {
  const options = [
    { size: base, type: 'full' },
    { size: 0.75 * base, type: 'threeq' },
    { size: 0.5 * base, type: 'half' }
  ];
  let best = null;
  for (const opt of options) {
    if (opt.size <= width + 0.1 && (!best || opt.size > best.size)) {
      best = opt;
    }
  }
  return best; // <-- GEEN fallback
}

function buildRow(verband, rowIndex, L, D, maxB, sv) {
  const stones = [];
  let x = 0;
  let sequence = [];

  switch (verband) {
    case 'halfsteen':
      if (rowIndex % 2 === 0) sequence = [{ isKop: false, base: L }];
      else {
        if (L/2 <= maxB) {
          stones.push({ x: 0, width: L/2, isKop: false, type: 'half' });
          x = L/2 + sv;
        } else {
          return stones;
        }
        sequence = [{ isKop: false, base: L }];
      }
      break;
    case 'kruis':
      if (rowIndex % 2 === 0) sequence = [{ isKop: false, base: L }];
      else sequence = [{ isKop: true, base: D }];
      break;
    case 'stapel':
    case 'wild':
      sequence = [{ isKop: false, base: L }];
      break;
    case 'staand':
      sequence = [{ isKop: true, base: D }];
      break;
    case 'klezoor':
      sequence = [{ isKop: false, base: L }, { isKop: true, base: D }];
      break;
    case 'ketting':
      sequence = [{ isKop: false, base: L }, { isKop: false, base: L }, { isKop: true, base: D }];
      break;
    case 'claustra':
      while (x < maxB) {
        if (x + L <= maxB) {
          stones.push({ x, width: L, isKop: false, type: 'full' });
        }
        x += L + sv;
        x += L + sv;
      }
      return stones;
    default:
      sequence = [{ isKop: false, base: L }];
  }

  if (verband === 'claustra') return stones;

  let idx = 0;
  while (x < maxB) {
    const item = sequence[idx % sequence.length];
    const rest = maxB - x;
    if (rest < Math.min(0.5 * item.base, 1)) break;

    const valid = getValidSize(rest, item.base);
    if (!valid) break;

    stones.push({ x, width: valid.size, isKop: item.isKop, type: valid.type });
    x += valid.size + sv;
    idx++;
    if (idx > 100) break;
  }

  // >>> VUL REST OP MET CUSTOM, MAAR ALLEEN ALS HET EEN AFZAGING IS (dus ‚â§ toegestaan formaat) <<<
  const remaining = maxB - x;
  if (remaining > 0.1 && stones.length > 0) {
    // We voegen geen losse steen toe, maar we weten dat remaining < 0.5 * base
    // Dus het is veilig om af te zagen van een halve steen
    stones.push({ x, width: remaining, isKop: false, type: 'custom' });
  }

  return stones;
}

$('#bereken').on('click', function () {
  const H = +$('#H').val();
  const B = +$('#B').val();
  const L = +$('#L').val();
  const D = +$('#D').val();
  const h = +$('#h').val();
  const lv = +$('#lv').val();
  const lv0 = +$('#lv0').val();
  const sv = +$('#sv').val();
  const verband = $('#verband').val();

  if ([H, B, L, D, h, lv, lv0, sv].some(isNaN) || H <= 0 || B <= 0 || L <= 0 || D <= 0 || h <= 0 || lv < 0 || lv0 < 0 || sv < 0) {
    $('#result').html('‚ùå Fout: alle waarden moeten positief getallen zijn.');
    return;
  }

  let rijen = 0;
  while (true) {
    const needed = lv0 + (rijen + 1) * h + rijen * lv;
    if (needed <= H) {
      rijen++;
    } else {
      break;
    }
    if (rijen > 200) break;
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const viewWidth = B + 50;
  const scale = Math.min(canvas.clientWidth / viewWidth, 800 / viewWidth);
  canvas.width = viewWidth * scale;
  canvas.height = H * scale;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#ff0000';
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 1;
  ctx.strokeRect(0, 0, B * scale, H * scale);
  ctx.setLineDash([]);

  const count = { full: 0, threeq: 0, half: 0, custom: 0 };
  const customSizes = {}; // breedte ‚Üí aantal
  const colorMap = { 
    full: '#c2b280', 
    threeq: '#aa9a60', 
    half: '#b5a570',
    custom: '#d9534f' // rood voor custom
  };

  for (let r = 0; r < rijen; r++) {
    const yFromBottom = lv0 + r * (h + lv);
    if (yFromBottom + h > H) continue;

    const row = buildRow(verband, r, L, D, B, sv);

    for (const stone of row) {
      if (stone.x >= 0 && stone.x + stone.width <= B + 0.1) {
        if (stone.type === 'custom') {
          count.custom++;
          const wRounded = Math.round(stone.width * 10) / 10; // afronden op 0.1 mm
          customSizes[wRounded] = (customSizes[wRounded] || 0) + 1;
          drawStone(ctx, stone.x, yFromBottom, stone.width, h, colorMap.custom, H, scale);
        } else {
          count[stone.type]++;
          drawStone(ctx, stone.x, yFromBottom, stone.width, h, colorMap[stone.type], H, scale);
        }
      }
    }
  }

  let suggestions = '';
  const base0 = (verband === 'staand' || (verband === 'kruis' && 0 % 2 === 1)) ? D : L;
  let bestSv = null;
  for (let n = 1; n <= Math.ceil(B / base0) + 3; n++) {
    if (n === 1) {
      if (Math.abs(base0 - B) <= 1) { bestSv = sv; break; }
    } else {
      const candidate = (B - n * base0) / (n - 1);
      if (candidate >= 0 && candidate <= 30) { bestSv = candidate; break; }
    }
  }
  if (bestSv !== null && Math.abs(bestSv - sv) > 0.5) {
    suggestions += `üí° Voor exacte breedte met volle stenen in rij 0: stootvoeg = ${bestSv.toFixed(1)} mm<br>`;
  }

  if (rijen > 0) {
    const usedHeight = lv0 + rijen * h + (rijen - 1) * lv;
    const diff = H - usedHeight;
    if (Math.abs(diff) > 0.5) {
      const newLv0 = lv0 + diff;
      if (newLv0 >= 0 && newLv0 <= h / 2) {
        suggestions += `üí° Voor exacte hoogte: pas lintvoeg onder rij 0 aan naar ${newLv0.toFixed(1)} mm (‚â§¬Ω steen)<br>`;
      }
    }
  }

  const total = count.full + count.threeq + count.half + count.custom;
  let resultText = `Ingevoerde waarden:<br>`;
  resultText += `&nbsp;&nbsp;H=${H} mm, B=${B} mm<br>`;
  resultText += `&nbsp;&nbsp;lv=${lv} mm, lv0=${lv0} mm, sv=${sv} mm<br><br>`;
  resultText += `Aantal rijen (van onder): ${rijen}<br>`;
  resultText += `Volle stenen (binnen muur): ${count.full}<br>`;
  resultText += `¬æ-stenen: ${count.threeq}<br>`;
  resultText += `Halve stenen: ${count.half}<br>`;
  
  // >>> NIEUW: toon custom stenen in legende <<<
  if (count.custom > 0) {
    resultText += `Aangepaste stenen (op maat): ${count.custom}<br>`;
    const sizeList = Object.keys(customSizes).sort((a,b) => parseFloat(a) - parseFloat(b));
    for (const w of sizeList) {
      resultText += `&nbsp;&nbsp;‚Ä¢ ${w} mm: ${customSizes[w]}√ó<br>`;
    }
  }
  
  resultText += `Totaal binnen muur: ${total}<br><br>`;

  if (suggestions) resultText += suggestions;
  resultText += `‚úÖ Alleen stenen binnen de muur (gestippeld kader) worden getoond en geteld.<br>`;
  resultText += `üìè Gestippelde rechthoek = opgegeven muur (B√óH).<br>`;
  if (count.custom > 0) {
    resultText += `‚ö†Ô∏è Rode stenen = afgezaagd op maat (geen standaardformaat).`;
  }

  $('#result').html(resultText);
});
</script>
</body>
</html>
