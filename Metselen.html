<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Metselverband Simulator ‚Äì Wienerberger Canvas</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: auto;
      padding: 20px;
    }
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    label {
      font-size: 13px;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    input, select {
      width: 90px;
      margin-left: 6px;
      padding: 2px;
    }
    button {
      margin-top: 12px;
      padding: 8px 18px;
      background: #2c7be5;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #1a68d1; }
    #result {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-weight: bold;
    }
    canvas {
      margin-top: 20px;
      border: 1px solid #666;
      background: #ffffff;
      display: block;
      width: 100%;
      max-width: 900px;
      height: auto;
    }
  </style>
</head>
<body>

<h2>Metselverband Simulator ‚Äì Wienerberger (Canvas)</h2>
<p><small>Rij 0 = onderste rij ‚Ä¢ Rechte randen ‚Ä¢ Alleen 1 / ¬æ / ¬Ω stenen</small></p>

<div class="input-group">
  <label>Muurhoogte (mm) <input id="H" type="number" value="520" min="50" max="5000"></label>
  <label>Muurbreedte (mm) <input id="B" type="number" value="1000" min="100" max="5000"></label>
  <label>Steen lengte <input id="L" type="number" value="210" min="100" max="400"></label>
  <label>Steen breedte <input id="D" type="number" value="100" min="50" max="200"></label>
  <label>Steen hoogte <input id="h" type="number" value="65" min="30" max="150"></label>
  <label>Lintvoeg <input id="lv" type="number" value="10" min="0" max="30"></label>
  <label>Lintvoeg onder rij 0 <input id="lv0" type="number" value="10" min="0" max="30"></label>
  <label>Stootvoeg <input id="sv" type="number" value="10" min="0" max="30"></label>
  <label>Verband
    <select id="verband">
      <option value="halfsteen">Halfsteensverband</option>
      <option value="kruis">Kruisverband</option>
      <option value="stapel">Stapelverband</option>
      <option value="wild">Wildverband</option>
      <option value="staand">Staand verband</option>
      <option value="klezoor">Klezoorverband</option>
      <option value="ketting">Kettingverband</option>
      <option value="claustra">Claustra</option>
    </select>
  </label>
</div>

<button id="bereken">Bereken & Visualiseer</button>
<div id="result"></div>
<canvas id="canvas"></canvas>

<script>
function drawStone(ctx, x, yFromBottom, w, h, color, H, scale) {
  const yCanvas = (H - (yFromBottom + h)) * scale;
  ctx.fillStyle = color;
  ctx.fillRect(x * scale, yCanvas, w * scale, h * scale);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(x * scale, yCanvas, w * scale, h * scale);
}

// Geeft toegestane stengrootte dichtst bij 'target', maar ‚â§ target indien possible
// Retourneert object met size en type, of null
function getClosestAllowedSize(target, base) {
  const options = [
    { size: base,     type: 'full' },
    { size: 0.75 * base, type: 'threeq' },
    { size: 0.5 * base,  type: 'half' }
  ];
  // Sorteer op absolute verschil, maar geef voorrang aan waarden ‚â§ target
  let best = null;
  for (const opt of options) {
    if (!best || Math.abs(opt.size - target) < Math.abs(best.size - target)) {
      best = opt;
    }
  }
  return best;
}

function buildRow(verband, rowIndex, L, D, maxB, sv) {
  const stones = [];
  let x = 0;
  let sequence = [];

  switch (verband) {
    case 'halfsteen':
      if (rowIndex % 2 === 0) sequence = [{ isKop: false, base: L }];
      else sequence = [{ isKop: false, base: L }]; // start later met halve
      break;
    case 'kruis':
      if (rowIndex % 2 === 0) sequence = [{ isKop: false, base: L }];
      else sequence = [{ isKop: true, base: D }];
      break;
    case 'stapel':
    case 'wild':
      sequence = [{ isKop: false, base: L }];
      break;
    case 'staand':
      sequence = [{ isKop: true, base: D }];
      break;
    case 'klezoor':
      sequence = [{ isKop: false, base: L }, { isKop: true, base: D }];
      break;
    case 'ketting':
      sequence = [{ isKop: false, base: L }, { isKop: false, base: L }, { isKop: true, base: D }];
      break;
    case 'claustra':
      while (x < maxB) {
        if (x + L <= maxB) {
          stones.push({ x, width: L, isKop: false, type: 'full' });
        }
        x += L + sv;
        x += L + sv; // opening
      }
      return stones;
    default:
      sequence = [{ isKop: false, base: L }];
  }

  if (verband === 'claustra') return stones;

  // Speciale behandeling voor oneven rijen bij halfsteen
  let offset = 0;
  if (verband === 'halfsteen' && rowIndex % 2 === 1) {
    // Begin met halve steen
    const half = 0.5 * L;
    if (half <= maxB) {
      stones.push({ x: 0, width: half, isKop: false, type: 'half' });
      x = half + sv;
    } else {
      // Geen ruimte ‚Üí geen stenen
      return [];
    }
  }

  // Bepaal basislengte voor deze rij
  const base = sequence[0].base;

  // Simuleer hoeveel volle stenen er zouden passen vanaf x
  let count = 0;
  let simulatedX = x;
  while (true) {
    const nextEnd = simulatedX + base;
    if (nextEnd <= maxB + 1e-9) {
      count++;
      simulatedX = nextEnd + sv;
    } else {
      break;
    }
  }

  if (count === 0) {
    // Probeer √©√©n steen van toegestaan formaat
    const rest = maxB - x;
    const allowed = getClosestAllowedSize(rest, base);
    if (allowed && allowed.size >= 0.5 * base - 1e-9) {
      stones.push({ x, width: allowed.size, isKop: sequence[0].isKop, type: allowed.type });
    }
    return stones;
  }

  // Bereken totale lengte met 'count' volle stenen
  const totalWithFull = x + count * base + (count - 1) * sv;
  const remainingSpace = maxB - totalWithFull;

  if (Math.abs(remainingSpace) <= 1e-9) {
    // Perfecte fit
    for (let i = 0; i < count; i++) {
      stones.push({ x: x + i * (base + sv), width: base, isKop: sequence[0].isKop, type: 'full' });
    }
  } else if (remainingSpace > 0) {
    // Ruimte over ‚Üí probeer laatste steen groter te maken (maar alleen naar toegestaan formaat)
    const targetLast = base + remainingSpace;
    const allowed = getClosestAllowedSize(targetLast, base);
    if (allowed.size >= base) {
      // Gebruik allowed.size, maar dan moet je misschien minder stenen nemen
      // Simpelere aanpak: gebruik (count-1) volle stenen + 1 aangepaste
      if (count >= 1) {
        for (let i = 0; i < count - 1; i++) {
          stones.push({ x: x + i * (base + sv), width: base, isKop: sequence[0].isKop, type: 'full' });
        }
        const lastX = x + (count - 1) * (base + sv);
        const lastWidth = maxB - lastX;
        const lastAllowed = getClosestAllowedSize(lastWidth, base);
        if (lastAllowed && lastAllowed.size >= 0.5 * base - 1e-9) {
          stones.push({ x: lastX, width: lastAllowed.size, isKop: sequence[0].isKop, type: lastAllowed.type });
        } else {
          // Fallback: gebruik gewoon de ruimte (noodoplossing)
          stones.push({ x: lastX, width: lastWidth, isKop: sequence[0].isKop, type: 'custom' });
        }
      } else {
        // Geen volle stenen ‚Üí direct aangepaste
        const allowed = getClosestAllowedSize(maxB - x, base);
        if (allowed) {
          stones.push({ x, width: allowed.size, isKop: sequence[0].isKop, type: allowed.type });
        }
      }
    } else {
      // Gebruik gewoon count volle stenen, laat rest leeg ‚Üí niet toegestaan!
      // Dus beter: verminder count met 1 en vul laatste aan
      if (count >= 2) {
        for (let i = 0; i < count - 1; i++) {
          stones.push({ x: x + i * (base + sv), width: base, isKop: sequence[0].isKop, type: 'full' });
        }
        const lastX = x + (count - 1) * (base + sv);
        const lastWidth = maxB - lastX;
        const lastAllowed = getClosestAllowedSize(lastWidth, base);
        if (lastAllowed && lastAllowed.size >= 0.5 * base - 1e-9) {
          stones.push({ x: lastX, width: lastAllowed.size, isKop: sequence[0].isKop, type: lastAllowed.type });
        }
      } else {
        // Alleen 1 steen mogelijk ‚Üí pas aan
        const allowed = getClosestAllowedSize(maxB - x, base);
        if (allowed) {
          stones.push({ x, width: allowed.size, isKop: sequence[0].isKop, type: allowed.type });
        }
      }
    }
  } else {
    // Te veel gebruikt ‚Üí verwijder laatste steen en vul rest aan
    if (count >= 2) {
      for (let i = 0; i < count - 1; i++) {
        stones.push({ x: x + i * (base + sv), width: base, isKop: sequence[0].isKop, type: 'full' });
      }
      const lastX = x + (count - 1) * (base + sv);
      const lastWidth = maxB - lastX;
      const lastAllowed = getClosestAllowedSize(lastWidth, base);
      if (lastAllowed && lastAllowed.size >= 0.5 * base - 1e-9) {
        stones.push({ x: lastX, width: lastAllowed.size, isKop: sequence[0].isKop, type: lastAllowed.type });
      }
    } else if (count === 1) {
      const allowed = getClosestAllowedSize(maxB - x, base);
      if (allowed) {
        stones.push({ x, width: allowed.size, isKop: sequence[0].isKop, type: allowed.type });
      }
    }
  }

  return stones;
}

$('#bereken').on('click', function () {
  const H = +$('#H').val();
  const B = +$('#B').val();
  const L = +$('#L').val();
  const D = +$('#D').val();
  const h = +$('#h').val();
  const lv = +$('#lv').val();
  const lv0 = +$('#lv0').val();
  const sv = +$('#sv').val();
  const verband = $('#verband').val();

  if ([H, B, L, D, h, lv, lv0, sv].some(isNaN) || H <= 0 || B <= 0 || L <= 0 || D <= 0 || h <= 0 || lv < 0 || lv0 < 0 || sv < 0) {
    $('#result').html('‚ùå Fout: alle waarden moeten positief getallen zijn.');
    return;
  }

  // Bepaal aantal rijen dat past
  let rijen = 0;
  while (true) {
    const needed = lv0 + (rijen + 1) * h + rijen * lv;
    if (needed <= H) {
      rijen++;
    } else {
      break;
    }
    if (rijen > 200) break;
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const viewWidth = B + 50;
  const scale = Math.min(canvas.clientWidth / viewWidth, 800 / viewWidth);
  canvas.width = viewWidth * scale;
  canvas.height = H * scale;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#ff0000';
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 1;
  ctx.strokeRect(0, 0, B * scale, H * scale);
  ctx.setLineDash([]);

  const count = { full: 0, threeq: 0, half: 0 };
  const colorMap = { full: '#c2b280', threeq: '#aa9a60', half: '#b5a570' };

  for (let r = 0; r < rijen; r++) {
    const yFromBottom = lv0 + r * (h + lv);
    // Stop als de bovenkant van de rij boven de muur uitkomt
    if (yFromBottom + h > H) continue;

    const row = buildRow(verband, r, L, D, B, sv);

    for (const stone of row) {
      // Controleer expliciet of de steen binnen de muur valt
      if (stone.x >= 0 && stone.x + stone.width <= B) {
        count[stone.type]++;
        drawStone(ctx, stone.x, yFromBottom, stone.width, h, colorMap[stone.type], H, scale);
      }
      // Stenen buiten worden genegeerd (niet getekend, niet geteld)
    }
  }

  // Suggesties
  let suggestions = '';
  const base0 = (verband === 'staand' || (verband === 'kruis' && 0 % 2 === 1)) ? D : L;
  let bestSv = null;
  for (let n = 1; n <= Math.ceil(B / base0) + 3; n++) {
    if (n === 1) {
      if (Math.abs(base0 - B) <= 1) { bestSv = sv; break; }
    } else {
      const candidate = (B - n * base0) / (n - 1);
      if (candidate >= 0 && candidate <= 30) { bestSv = candidate; break; }
    }
  }
  if (bestSv !== null && Math.abs(bestSv - sv) > 0.5) {
    suggestions += `üí° Voor exacte breedte met volle stenen in rij 0: stootvoeg = ${bestSv.toFixed(1)} mm<br>`;
  }

  if (rijen > 0) {
    const usedHeight = lv0 + rijen * h + (rijen - 1) * lv;
    const diff = H - usedHeight;
    if (Math.abs(diff) > 0.5) {
      const newLv0 = lv0 + diff;
      if (newLv0 >= 0 && newLv0 <= h / 2) {
        suggestions += `üí° Voor exacte hoogte: pas lintvoeg onder rij 0 aan naar ${newLv0.toFixed(1)} mm (‚â§¬Ω steen)<br>`;
      }
    }
  }

  const total = count.full + count.threeq + count.half;
  let resultText = `Ingevoerde waarden:<br>`;
  resultText += `&nbsp;&nbsp;H=${H} mm, B=${B} mm<br>`;
  resultText += `&nbsp;&nbsp;lv=${lv} mm, lv0=${lv0} mm, sv=${sv} mm<br><br>`;
  resultText += `Aantal rijen (van onder): ${rijen}<br>`;
  resultText += `Volle stenen (binnen muur): ${count.full}<br>`;
  resultText += `¬æ-stenen: ${count.threeq}<br>`;
  resultText += `Halve stenen: ${count.half}<br>`;
  resultText += `Totaal binnen muur: ${total}<br><br>`;

  if (suggestions) resultText += suggestions;
  resultText += `‚úÖ Alleen stenen binnen de muur (gestippeld kader) worden getoond en geteld.<br>`;
  resultText += `üìè Gestippelde rechthoek = opgegeven muur (B√óH).`;

  $('#result').html(resultText);
});
</script>
</body>
</html>
